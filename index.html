<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Upload to S3</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            color: #333;
        }

        .main-container {
            display: flex;
            gap: 20px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .content-column {
            flex: 7;
            min-width: 0;
        }

        .log-column {
            flex: 3;
            min-width: 820px;
        }

        h1, h2 {
            border-bottom: 2px solid #0066cc;
            padding-bottom: 10px;
            color: #0066cc;
        }

        form, .download-section {
            background-color: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #ddd;
        }

        .download-section {
            display: flex;
            justify-content: space-between;
        }

        .download-method {
            flex: 1;
            padding: 15px;
            margin: 0 10px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        label {
            font-weight: bold;
            display: inline-block;
            width: 70px;
        }

        input[type="file"] {
            padding: 10px 0;
            margin-bottom: 15px;
        }

        button, input[type="submit"] {
            background-color: #0066cc;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            width: 100%;
        }

        button:hover, input[type="submit"]:hover {
            background-color: #0055aa;
        }

        .api-log {
            position: sticky;
            top: 20px;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            background-color: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .api-log h2 {
            color: #0066cc;
            margin-top: 0;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        #apiLogs {
            max-height: 90vh;
            overflow-y: auto;
        }

        .log-entry {
            margin-bottom: 15px;
            padding: 12px;
            border-left: 4px solid #0066cc;
            background-color: #f0f7ff;
            border-radius: 0 4px 4px 0;
            transition: all 0.3s ease;
        }

        .log-entry:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .log-entry h3 {
            margin-top: 0;
            color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-entry h4 {
            color: #0066cc;
            margin-bottom: 5px;
            border-bottom: 1px dashed #ccc;
            padding-bottom: 5px;
        }

        pre {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            max-height: 300px;
            border: 1px solid #ddd;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .latency {
            background-color: #e8f5e9;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 14px;
            color: #2e7d32;
            margin-left: 10px;
            display: inline-block;
        }

        .status-success {
            color: #2e7d32;
        }

        .status-error {
            color: #c62828;
        }

        .image-result {
            margin-top: 10px;
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            display: none;
        }

        video.image-result {
            display: block;
            width: 100%;
        }

        .performance-comparison {
            background-color: #fff8e1;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            border: 1px solid #ffe082;
        }

        .file-select {
            display: block;
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #fff;
            font-size: 14px;
        }

        .media-container {
            margin-top: 10px;
            width: 100%;
        }

        #expireButtons {
            display: flex;
            flex-direction: row;
            gap: 10px;
        }
    </style>
</head>
<body>
<div class="main-container">
    <div class="content-column">
        <h1>Upload to S3</h1>
        <p>Upload a file to Amazon S3 using a presigned POST request.</p>

        <form enctype="multipart/form-data" id="uploadForm">
            <label for="file">File:</label>
            <input id="file" name="file" required type="file"/> <br/>
            <input name="submit" type="submit" value="Upload to Amazon S3"/>
        </form>


        <h2>Media Download Comparison</h2>
        <p>Compare download performance between valet key pattern and server proxy.</p>

        <div class="download-section">
            <div class="download-method">
                <h3>Valet Key Method</h3>
                <p>Client directly downloads from S3 using a presigned URL</p>
                <select class="file-select" id="valetFileSelect">
                    <option value="image.png">image.png</option>
                    <option value="7mb.jpg">7mb.jpg (7MB)</option>
                    <option value="15mb.png">15mb.png (15MB)</option>
                    <option value="sample.mp4">sample.mp4 (Video)</option>
                </select>
                <button id="downloadValet">Download with Valet Key</button>
                <div class="media-container" id="valetImage"></div>
                <div id="valetStats"></div>
            </div>

            <div class="download-method">
                <h3>Server Proxy Method</h3>
                <p>Server downloads from S3 and forwards to client</p>
                <select class="file-select" id="proxyFileSelect">
                    <option value="image.png">image.png</option>
                    <option value="7mb.jpg">7mb.jpg (7MB)</option>
                    <option value="15mb.png">15mb.png (15MB)</option>
                    <option value="sample.mp4">sample.mp4 (Video)</option>
                </select>
                <button id="downloadProxy">Download via Server</button>
                <div class="media-container" id="proxyImage"></div>
                <div id="proxyStats"></div>
            </div>
        </div>

        <button id="compareSimultaneously"
                style="display: block; margin: 20px auto; width: 50%; background-color: #4CAF50;">
            Compare Both Methods Simultaneously
        </button>

        <div class="performance-comparison" id="performanceComparison" style="display: none;">
            <h3>Performance Comparison</h3>
            <div id="comparisonResults"></div>
        </div>

        <h2>URL Expiration Test</h2>
        <p>Test downloading with the same URL multiple times to observe URL expiration behavior.</p>

        <div class="download-section">
            <div class="download-method" style="flex: 100%;">
                <h3>Valet Key URL Expiration Test</h3>
                <p>The presigned URL from "Download with Valet Key" will expire after 30 seconds</p>

                <div id="expiringUrlDisplay"
                     style="display: none; margin: 15px 0; padding: 10px; background: #f0f7ff; border-left: 4px solid #0066cc;">
                    <p><strong>Using the same Valet URL</strong></p>
                    <p><strong>Expires in:</strong> <span id="countdown">30</span> seconds</p>
                    <p><strong>Current time:</strong> <span id="currentTime"></span></p>
                    <p><strong>Expiry time:</strong> <span id="expiryTime"></span></p>
                </div>

                <div id="expireButtons" style="display: none;">
                    <button id="tryBeforeExpiry">Download with Same URL Now</button>
                    <button id="tryAfterExpiry">Wait & Download After URL Expires</button>
                </div>

                <div class="media-container" id="expireImage"></div>
                <div id="expireStats"></div>
            </div>
        </div>
    </div>

    <div class="log-column">
        <div class="api-log">
            <h2>API Call Logs</h2>
            <div id="apiLogs"></div>
        </div>
    </div>
</div>
<script>
    // Use dynamic base URL instead of hardcoded localhost
    const apiBaseUrl = window.location.origin;

    function displayMedia(blob, elementId) {
        // Clean up any previous object URLs to prevent memory leaks
        const container = document.getElementById(elementId);
        const existingMedia = container.querySelector('img, video');

        if (existingMedia) {
            // Revoke the old object URL if it exists
            if (existingMedia.src && existingMedia.src.startsWith('blob:')) {
                URL.revokeObjectURL(existingMedia.src);
            }
        }

        // Clear the container contents
        container.innerHTML = '';

        // Create new object URL and display media
        const url = URL.createObjectURL(blob);

        if (blob.type.startsWith('video/')) {
            const video = document.createElement('video');
            video.src = url;
            video.controls = true;
            video.autoplay = false;
            video.className = 'image-result';
            video.style.display = 'block';
            container.appendChild(video);
        } else {
            const img = document.createElement('img');
            img.src = url;
            img.className = 'image-result';
            img.style.display = 'block';
            container.appendChild(img);
        }

        return url;
    }

    // Function to add a log entry
    function logApiCall(title, request, response, latencyMs) {
        const logsContainer = document.getElementById("apiLogs");
        const logEntry = document.createElement("div");
        logEntry.className = "log-entry";

        const timestamp = new Date().toLocaleTimeString();
        const latencyText = latencyMs ? `<span class="latency">${latencyMs}ms</span>` : '';

        // Determine if this is a success or error
        const statusClass = response.error ? 'status-error' : 'status-success';

        logEntry.innerHTML = `
                        <h3>${timestamp} - ${title} ${latencyText}</h3>
                        <h4>Request:</h4>
                        <pre>${JSON.stringify(request, null, 2)}</pre>
                        <h4>Response:</h4>
                        <pre class="${statusClass}">${JSON.stringify(response, null, 2)}</pre>
                    `;

        logsContainer.prepend(logEntry);
    }


    // Upload functionality
    document.getElementById("uploadForm").addEventListener("submit", async function (event) {
        event.preventDefault();
        const file = event.target.elements.file.files[0];

        // Log the request for presigned URL
        const presignedRequest = {
            url: apiBaseUrl + "/",
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: {type: file.type}
        };

        try {
            // Measure presigned URL request time
            const presignedStartTime = performance.now();

            // Get presigned URL
            const presignedPost = await requestPresignedPost(file);

            const presignedEndTime = performance.now();
            const presignedLatency = Math.round(presignedEndTime - presignedStartTime);

            // Log the presigned response
            logApiCall("Request Presigned URL", presignedRequest, presignedPost, presignedLatency);

            const uploadedFileUrl = await uploadFile(file, presignedPost);

        } catch (error) {
            logApiCall("Error", {}, {
                error: error.message
            });
        }
    });

    async function uploadFile(file, presignedPost) {
        const formData = new FormData();
        formData.append("Content-Type", file.type);
        Object.entries(presignedPost.fields).forEach(([key, value]) => {
            formData.append(key, value);
        });
        formData.append("file", file);
        const uploadStartTime = performance.now();



        const res = await window.fetch(presignedPost.url, {
            method: "POST",
            body: formData,
        });
        const uploadEndTime = performance.now();
        const uploadLatency = Math.round(uploadEndTime - uploadStartTime);
        logApiCall("Upload to S3", {
            url: presignedPost.url,
            method: "POST",
            body: formData,
        }, {
            status: res.status,
            statusText: res.statusText,
            uploadedFileUrl: res.headers.get('Location'),
        }, uploadLatency);

        const location = res.headers.get("Location"); // get the final url of our uploaded image
        return decodeURIComponent(location);
    }

    // Download with Valet Key
    document.getElementById("downloadValet").addEventListener("click", async function () {
        try {
            const startTime = performance.now();

            // Get the selected file key from dropdown
            const fileKey = document.getElementById("valetFileSelect").value;

            // Request presigned URL for download
            const requestStart = performance.now();
            const requestDetails = {
                url: apiBaseUrl + "/presigned-get?key=" + fileKey,
                method: "GET"
            };
            const response = await fetch(apiBaseUrl + "/presigned-get?key=" + fileKey);
            if (!response.ok) {
                throw new Error(`Failed to fetch presigned URL: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            const requestEnd = performance.now();

            // Log the presigned URL request
            logApiCall("Get Presigned Download URL", requestDetails, data, Math.round(requestEnd - requestStart));

            // Download the image using the presigned URL
            const downloadStart = performance.now();
            const imageResponse = await fetch(data.url);


            const blob = await imageResponse.blob();
            const downloadEnd = performance.now();

            // Create object URL and display media
            const imageUrl = displayMedia(blob, "valetImage");

            const totalTime = performance.now() - startTime;
            const requestTime = requestEnd - requestStart;
            const downloadTime = downloadEnd - downloadStart;

            // Display stats
            document.getElementById("valetStats").innerHTML = `
                            <p><strong>Total time:</strong> ${Math.round(totalTime)}ms</p>
                            <p><strong>Get presigned URL:</strong> ${Math.round(requestTime)}ms</p>
                            <p><strong>Download from S3:</strong> ${Math.round(downloadTime)}ms</p>
                            <p><strong>File size:</strong> ${(blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                        `;

            // Update comparison
            updateComparison("valet", totalTime);

            // Log the download
            logApiCall("Download with Valet Key", {
                url: data.url,
                method: "GET",
                fileKey: fileKey
            }, {
                status: "Success",
                size: `${(blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: blob.type
            }, Math.round(downloadTime));

        } catch (error) {
            logApiCall("Error in Valet Download", {
                url: apiBaseUrl + "/presigned-get?key=" + document.getElementById("valetFileSelect").value,
                method: "GET"
            }, {
                error: error.message
            });
            document.getElementById("valetStats").innerHTML = `
                            <p class="status-error"><strong>Error:</strong> ${error.message}</p>
                        `;
        }
    });

    // Download via Server Proxy
    document.getElementById("downloadProxy").addEventListener("click", async function () {
        try {
            const startTime = performance.now();

            // Get the selected file key from dropdown
            const fileKey = document.getElementById("proxyFileSelect").value;

            // Request image through server proxy - fixed URL formation
            const response = await fetch(apiBaseUrl + "/proxy-image?key=" + fileKey);
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
            }

            const blob = await response.blob();

            // Create object URL and display media
            const imageUrl = displayMedia(blob, "proxyImage");

            const totalTime = performance.now() - startTime;

            // Display stats
            document.getElementById("proxyStats").innerHTML = `
                            <p><strong>Total time:</strong> ${Math.round(totalTime)}ms</p>
                            <p><strong>File size:</strong> ${(blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                        `;

            // Update comparison
            updateComparison("proxy", totalTime);

            // Log the download
            logApiCall("Download via Server Proxy", {
                url: apiBaseUrl + "/proxy-image?key=" + fileKey,
                method: "GET"
            }, {
                status: "Success",
                size: `${(blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: blob.type
            }, Math.round(totalTime));

        } catch (error) {
            logApiCall("Error in Server Proxy Download", {
                url: apiBaseUrl + "/proxy-image?key=" + document.getElementById("proxyFileSelect").value,
                method: "GET"
            }, {
                error: error.message
            });
            document.getElementById("proxyStats").innerHTML = `
                            <p class="status-error"><strong>Error:</strong> ${error.message}</p>
                        `;
        }
    });

    // Function to update comparison results
    const perfData = {
        valet: null,
        proxy: null
    };

    function updateComparison(method, time) {
        perfData[method] = time;

        // Only show comparison when both methods have been tested
        if (perfData.valet && perfData.proxy) {
            const comparison = document.getElementById("performanceComparison");
            comparison.style.display = "block";

            const diff = Math.abs(perfData.valet - perfData.proxy);
            const faster = perfData.valet < perfData.proxy ? "Valet Key" : "Server Proxy";
            const percentage = Math.round((diff / Math.max(perfData.valet, perfData.proxy)) * 100);

            document.getElementById("comparisonResults").innerHTML = `
                            <p><strong>Valet Key method:</strong> ${Math.round(perfData.valet)}ms</p>
                            <p><strong>Server Proxy method:</strong> ${Math.round(perfData.proxy)}ms</p>
                            <p><strong>Result:</strong> ${faster} method was ${percentage}% faster (${Math.round(diff)}ms difference)</p>
                        `;
        }
    }

    // Upload functions
    async function requestPresignedPost(file) {
        const {type} = file;
        const res = await window.fetch(apiBaseUrl + "/", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                type,
            }),
        });
        return res.json();
    }


    document.getElementById("compareSimultaneously").addEventListener("click", async function () {
        try {
            // Reset previous results
            document.getElementById("valetStats").innerHTML = '<p><strong>Status:</strong> Loading...</p>';
            document.getElementById("proxyStats").innerHTML = '<p><strong>Status:</strong> Loading...</p>';

            const valetFileKey = document.getElementById("valetFileSelect").value;
            const proxyFileKey = document.getElementById("proxyFileSelect").value;

            // Start both downloads simultaneously using Promise.all
            const startTime = performance.now();

            // Run both requests in parallel
            const [valetResult, proxyResult] = await Promise.all([
                (async () => {
                    // Valet key download
                    const valetStartTime = performance.now();

                    // Request presigned URL for download
                    const response = await fetch(`${apiBaseUrl}/presigned-get?key=${valetFileKey}`);
                    const data = await response.json();

                    // Download the media using the presigned URL
                    const mediaResponse = await fetch(data.url);
                    const blob = await mediaResponse.blob();

                    // Create object URL and display media
                    const mediaUrl = displayMedia(blob, "valetImage");

                    const valetTime = performance.now() - valetStartTime;

                    return {
                        time: valetTime,
                        blob: blob,
                        method: "valet"
                    };
                })(),

                (async () => {
                    // Server proxy download
                    const proxyStartTime = performance.now();

                    // Request media through server proxy
                    const response = await fetch(`${apiBaseUrl}/proxy-image?key=${proxyFileKey}`);
                    const blob = await response.blob();

                    // Create object URL and display media
                    const mediaUrl = displayMedia(blob, "proxyImage");

                    const proxyTime = performance.now() - proxyStartTime;

                    return {
                        time: proxyTime,
                        blob: blob,
                        method: "proxy"
                    };
                })()
            ]);

            // Show results
            document.getElementById("valetStats").innerHTML = `
                            <p><strong>Total time:</strong> ${Math.round(valetResult.time)}ms</p>
                            <p><strong>File size:</strong> ${(valetResult.blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                        `;

            document.getElementById("proxyStats").innerHTML = `
                            <p><strong>Total time:</strong> ${Math.round(proxyResult.time)}ms</p>
                            <p><strong>File size:</strong> ${(proxyResult.blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                        `;

            // Update comparison
            updateComparison("valet", valetResult.time);
            updateComparison("proxy", proxyResult.time);

            // Log the simultaneous download
            logApiCall("Simultaneous Download (Valet)", {
                url: `${apiBaseUrl}/presigned-get?key=${valetFileKey}`,
                method: "GET"
            }, {
                status: "Success",
                size: `${(valetResult.blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: valetResult.blob.type
            }, Math.round(valetResult.time));

            logApiCall("Simultaneous Download (Proxy)", {
                url: `${apiBaseUrl}/proxy-image?key=${proxyFileKey}`,
                method: "GET"
            }, {
                status: "Success",
                size: `${(proxyResult.blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: proxyResult.blob.type
            }, Math.round(proxyResult.time));

        } catch (error) {
            logApiCall("Error in Simultaneous Download", {}, {
                error: error.message
            });

            document.getElementById("valetStats").innerHTML = `
                            <p class="status-error"><strong>Error:</strong> ${error.message}</p>
                        `;
            document.getElementById("proxyStats").innerHTML = `
                            <p class="status-error"><strong>Error:</strong> ${error.message}</p>
                        `;
        }
    });
    // Global variables to store the last used valet URL and expiry time
    let lastValetUrl = null;
    let urlExpireTime = 0;
    let countdownInterval = null;

    // Hook into the existing downloadValet event listener
    const originalValetClick = document.getElementById("downloadValet").onclick;
    document.getElementById("downloadValet").onclick = async function (event) {
        // First, call the original handler
        if (typeof originalValetClick === 'function') {
            await originalValetClick.call(this, event);
        }

        // Now, capture the URL that was used and set up our expiration test
        const valetBtn = document.getElementById("downloadValet");
        const currentBtn = this;

        // Only proceed if we're the actual downloadValet button
        if (valetBtn === currentBtn) {
            // Make buttons and info visible
            document.getElementById("expiringUrlDisplay").style.display = "block";
            document.getElementById("expireButtons").style.display = "block";

            // Set up URL expiration countdown (AWS S3 default is 30 seconds)
            urlExpireTime = Date.now() + 30000; // 30 seconds from now

            // Update timestamps
            document.getElementById("currentTime").textContent = new Date().toLocaleTimeString();
            document.getElementById("expiryTime").textContent = new Date(urlExpireTime).toLocaleTimeString();

            // Clear previous countdown
            if (countdownInterval) {
                clearInterval(countdownInterval);
            }

            // Start countdown
            startUrlCountdown();
        }
    };

    function startUrlCountdown() {
        const countdownElement = document.getElementById("countdown");
        countdownInterval = setInterval(() => {
            const secondsLeft = Math.max(0, Math.floor((urlExpireTime - Date.now()) / 1000));
            countdownElement.textContent = secondsLeft;

            // When expired, update styling
            if (secondsLeft === 0) {
                clearInterval(countdownInterval);
                countdownElement.style.color = "red";
                countdownElement.parentElement.innerHTML = countdownElement.parentElement.innerHTML.replace(
                    "Expires in:", "<span style='color: red;'>EXPIRED</span>"
                );
            }
        }, 1000);
    }

    // Try download before URL expires
    document.getElementById("tryBeforeExpiry").addEventListener("click", async function () {
        try {
            // Clear any existing media in the container first
            const container = document.getElementById("expireImage");
            const existingMedia = container.querySelector('img, video');
            if (existingMedia) {
                if (existingMedia.src && existingMedia.src.startsWith('blob:')) {
                    URL.revokeObjectURL(existingMedia.src);
                }
            }
            container.innerHTML = '';

            // Get the last used URL from the logs
            const apiLogs = document.getElementById("apiLogs").children;
            let presignedUrlEntry = null;

            // Find the most recent presigned URL log entry
            for (let i = 0; i < apiLogs.length; i++) {
                if (apiLogs[i].innerHTML.includes("Get Presigned Download URL")) {
                    presignedUrlEntry = apiLogs[i];
                    break;
                }
            }

            if (!presignedUrlEntry) {
                throw new Error("No presigned URL found. Please click 'Download with Valet Key' first.");
            }

            // Extract the URL from the log entry
            const urlMatch = presignedUrlEntry.innerHTML.match(/"url":\s*"([^"]+)"/);
            if (!urlMatch || !urlMatch[1]) {
                throw new Error("Could not find URL in log entry");
            }

            const data = JSON.parse(presignedUrlEntry.querySelector("pre:last-of-type").textContent);
            const startTime = performance.now();

            // Show status
            document.getElementById("expireStats").innerHTML = `
                <p><strong>Status:</strong> Downloading with same URL...</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired?</strong> ${Date.now() > urlExpireTime ? "Yes" : "No"}</p>
            `;

            // Use the URL directly from the log
            const imageResponse = await fetch(data.url, {
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache'
                }
            });

            if (!imageResponse.ok) {
                throw new Error(`Failed with status: ${imageResponse.status} - ${imageResponse.statusText}`);
            }

            const blob = await imageResponse.blob();
            displayMedia(blob, "expireImage");

            const totalTime = performance.now() - startTime;

            document.getElementById("expireStats").innerHTML = `
                <p><strong>Total time:</strong> ${Math.round(totalTime)}ms</p>
                <p><strong>File size:</strong> ${(blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                <p class="status-success"><strong>Status:</strong> Success</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired?</strong> ${Date.now() > urlExpireTime ? "Yes" : "No"}</p>
            `;

            logApiCall("Reused URL Download", {
                url: data.url.substring(0, 50) + "...",
                method: "GET"
            }, {
                status: "Success",
                size: `${(blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: blob.type,
                urlExpired: Date.now() > urlExpireTime ? "Yes" : "No"
            }, Math.round(totalTime));

        } catch (error) {
            // Get the URL from the logs (if possible) to include in the error log
            let urlInfo = {};
            try {
                const apiLogs = document.getElementById("apiLogs").children;
                let presignedUrlEntry = null;
                for (let i = 0; i < apiLogs.length; i++) {
                    if (apiLogs[i].innerHTML.includes("Get Presigned Download URL")) {
                        presignedUrlEntry = apiLogs[i];
                        break;
                    }
                }

                if (presignedUrlEntry) {
                    const data = JSON.parse(presignedUrlEntry.querySelector("pre:last-of-type").textContent);
                    urlInfo = {
                        url: data.url.substring(0, 50) + "...",
                        method: "GET"
                    };
                }
            } catch (e) {
                urlInfo = {method: "GET", error: "Could not extract URL info"};
            }

            document.getElementById("expireStats").innerHTML = `
                <p class="status-error"><strong>Error:</strong> ${error.message}</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired?</strong> ${Date.now() > urlExpireTime ? "Yes" : "No"}</p>
            `;

            logApiCall("Reused URL Download Error", urlInfo, {
                error: error.message,
                expired: Date.now() > urlExpireTime ? "Yes" : "No"
            });
        }
    });

    // Wait for expiry and try download
    document.getElementById("tryAfterExpiry").addEventListener("click", async function () {
        try {
            // Get the last used URL from the logs
            const apiLogs = document.getElementById("apiLogs").children;
            let presignedUrlEntry = null;

            // Find the most recent presigned URL log entry
            for (let i = 0; i < apiLogs.length; i++) {
                if (apiLogs[i].innerHTML.includes("Get Presigned Download URL")) {
                    presignedUrlEntry = apiLogs[i];
                    break;
                }
            }

            if (!presignedUrlEntry) {
                throw new Error("No presigned URL found. Please click 'Download with Valet Key' first.");
            }

            const data = JSON.parse(presignedUrlEntry.querySelector("pre:last-of-type").textContent);

            // Calculate time until expiry
            const timeUntilExpiry = urlExpireTime - Date.now();

            if (timeUntilExpiry > 0) {

                const waitTime = timeUntilExpiry + 2000;
                const waitSeconds = Math.ceil(waitTime / 1000);

                document.getElementById("expireStats").innerHTML = `
                    <p><strong>Status:</strong> Waiting ${waitSeconds} seconds for URL to expire...</p>
                    <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                    <p><strong>URL expires at:</strong> ${new Date(urlExpireTime).toLocaleTimeString()}</p>
                `;

                // Wait until expiry plus buffer
                await new Promise(resolve => setTimeout(resolve, waitTime));
            }

            const startTime = performance.now();

            // Show status
            document.getElementById("expireStats").innerHTML = `
                <p><strong>Status:</strong> Attempting download with expired URL...</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired:</strong> ${Math.round((Date.now() - urlExpireTime) / 1000)}s ago</p>
            `;

            // Try to use the expired URL
            const imageResponse = await fetch(data.url, {
                cache: 'no-store',
                headers: {
                    'Cache-Control': 'no-cache, no-store, must-revalidate',
                    'Pragma': 'no-cache'
                }
            });

            if (!imageResponse.ok) {
                throw new Error(`Failed with status: ${imageResponse.status} - ${imageResponse.statusText}`);
            }

            const blob = await imageResponse.blob();
            displayMedia(blob, "expireImage");

            const totalTime = performance.now() - startTime;

            document.getElementById("expireStats").innerHTML = `
                <p><strong>Total time:</strong> ${Math.round(totalTime)}ms</p>
                <p><strong>File size:</strong> ${(blob.size / (1024 * 1024)).toFixed(2)} MB</p>
                <p class="status-success"><strong>Status:</strong> Success (unexpected - URL should be expired!)</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired:</strong> ${Math.round((Date.now() - urlExpireTime) / 1000)}s ago</p>
            `;

            logApiCall("Post-Expiry URL Download", {
                url: data.url.substring(0, 50) + "...",
                method: "GET"
            }, {
                status: "Success (unexpected)",
                size: `${(blob.size / (1024 * 1024)).toFixed(2)} MB`,
                type: blob.type,
                secondsAfterExpiry: Math.round((Date.now() - urlExpireTime) / 1000)
            }, Math.round(totalTime));

        } catch (error) {
            // This is actually the expected outcome - error on expired URL
            document.getElementById("expireStats").innerHTML = `
                <p class="status-success"><strong>Expected result:</strong> ${error.message}</p>
                <p><strong>Current time:</strong> ${new Date().toLocaleTimeString()}</p>
                <p><strong>URL expired:</strong> ${Math.round((Date.now() - urlExpireTime) / 1000)}s ago</p>
                <p>This is the expected behavior - AWS S3 presigned URLs should fail after expiration.</p>
            `;

            logApiCall("Post-Expiry URL Download", {
                method: "GET"
            }, {
                status: "Expected failure (URL expired)",
                error: error.message,
                secondsAfterExpiry: Math.round((Date.now() - urlExpireTime) / 1000)
            });
        }
    });
</script>
</body>
</html>